# Handling data

After we have loaded/imported our data we want to be able to work with it. Typical operations are to extract specific columns, rows, or values, and to add new columns and rows. Recall that **columns** run top to bottom, while **rows** run left to right.

In addition, columns will sometimes have names:
```{r, include=F}
data1 <- read.csv(file = "solution-concentration-effect-on-potato.csv")
```
```{r}
names(data1)
```
To extract a column, we use the symbol `$` followed by the name of the column (in this case `NaCl.0.percent`):
```{r}
  data1$NaCl.0.percent
```
If the columns do not have names you can specify the column you require by using `data1[,n]`, where `n` is the number of column you require (beginning from the left). When no number precedes the `,n` this means _all rows_:
```{r}
data1[,1]
```
To extract row `n`, and all the columns, we use `data1[n,]`. Row 1 (all columns) is extracted as:
```{r}
  data1[1,]
```

If we want one specific value, `data1[n,m]` returns the value in row `n` and column `m`:

```{r}
  data1[1,2]
```
Furthermore, `data1[,n:m]` returns all the rows for columns `n` to `m`:

```{r}
  data1[2:4,]
```

while `data1[n:m,]` returns all the columns for rows `n` to `m`:
```{r}
  data1[,1:3]
```

Note that in the two examples above `n` must be bigger than `m`. This method is called _slicing_.

This are simple commands to work with data, but as data scientists frequently want to work with data in this way, the `dplyr` package was created to handle data more efficiently.

## dplyr
We recommend using `dplyr` to handle data as the commands are concise, making the code easier to read and write.

```{r, include=F, echo=F}
# additional information not include in on the website
library(dplyr)

```
