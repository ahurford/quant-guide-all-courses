# Handling data

## Extracting rows and columns
After we have loaded/imported our data we want to be able to work with it. Typical operations are to extract specific columns, rows, or values, and to add new columns and rows. Recall that **columns** run top to bottom, while **rows** run left to right.

In addition, columns will sometimes have names:
```{r, include=F}
data <- read.csv(file = "shrub-volume-data.csv")
```
```{r}
names(data)
```
To extract a column, we use the symbol `$` followed by the name of the column (in this case `site`):
```{r}
  data$site
```
If the columns do not have names you can specify the column you require by using `data[,n]`, where `n` is the number of column you require (beginning from the left). When no number precedes the `,n` this means _all rows_:
```{r}
data[,1]
```
To extract row `n`, and all the columns, we use `data[n,]`. Row 1 (all columns) is extracted as:
```{r}
  data[1,]
```

If we want one specific value, `data[n,m]` returns the value in row `n` and column `m`:

```{r}
  data[1,2]
```
Furthermore, `data[,n:m]` returns all the rows for columns `n` to `m`:

```{r}
  data[2:4,]
```

while `data[n:m,]` returns all the columns for rows `n` to `m`:
```{r}
  data[,2:3]
```

Note that in the two examples above `n` must be bigger than `m`. This method is called _slicing_.

This are simple commands to work with data, but as data scientists frequently want to work with data in this way, the `dplyr` package was created to handle data more efficiently.

## dplyr
We recommend using `dplyr` to handle data as the commands are concise, making the code easier to read and write. [Install and load](https://ahurford.github.io/quant-guide-all-courses/rintro.html#r-packages) the <u>[dplyr](rdocumentation.org/packages/dplyr/versions/0.7.8)</u> R package.

```{r, include=F, echo=F}
library(dplyr)
```

The [dplyr](rdocumentation.org/packages/dplyr/versions/0.7.8) package contains several different function that are very useful when manipulating and cleaning large datasets. We will be highlighting the use of the `select()`, `mutate()`, `length()`, `arrange()`, and `filter()`.

### Selecting a column
The command `select(data, length)` selects the `length` column of the dataframe `data`:

```{r, echo=T}
select(data, length)
```

This achieves the same result as the `data$length` command we learned in the previous section.

### Adding a new column

There are several different methods to add new columns to a data set in R, but when using the `dplyr` package, the function `mutate()` is appropriate. Below we create a new column called `site_double` that is equal to the `site` column times 2.

```{r}
data2 = mutate(data, site_double = site * 2)
```

We can see that `data2` has a new column called `site_double`.

### Sorting the data

The `arrange()` function orders the rows of a data frame by the values in a specific column. Below we arrange `data` by increasing order of the `width` column.:

```{r}
arrange(data, width)
```


### Filtering data

The `filter()` function is used to subset a data frame, retaining all rows that satisfy your conditions. For a row to be retained, `TRUE` must be produced for all conditions. To extract all rows of `data` with length greater than 7 cm:

```{r}
filter(data, height > 7)
```

We can also filter with two (or more) conditions. We use `&` (meaning _and_) if we require _both_ conditions to be satisfied, or `|` (meaning _or_) if we require _at least one_ condition is satisfied. Below, we filter the `data` so that `data3` contains only plants that have length greater than 8 cm and width greater than 5 cm.

```{r}
data3=filter(data, height >8 & width > 5)
```

However, no plants met both conditions so `data3` is empty.

We can filter to retain plants from Site 1 or Site 3:

```{r}
filter(data, site == 1 |site == 3)
```

In R,  `==` evaluates whether something is `TRUE` or `FALSE`, while `=` assigns the value on the right hand side to the variable on the left hand side. **TRY IT** In the `Console` try the following:


```{r}
# Assigns x the value 0
x = 0
# Evaluates TRUE if x = 0 (TRUE since we assigned x=0 on the above line of code)
x == 0
# Evalues TRUE if x = 1 (FALSE since we assigned x=0 on the first line of code)
x == 1
```

Therefore, when we write `site == 1`, `TRUE` is returned when the value of `site` is `1`, and these rows are retained in the output. If we wrote `site = 1`, then `R` would try to assign the variable `site` with the value `1`, which would return an error message since the second argument of the `filter()` function requires a logical statement that evaluates as `TRUE` or `FALSE` and `site = 1` assigns a value; it is not a logical statement.

### Removing NA entries in data

 Often experimental data is not as neat or pretty as example data. There is often missing data, or empty or `NA` entries which may cause issues in graphing or data analysis. `R` does not allow empty values, so empty values in `.csv` or `.xlsx` files are often converted to `NA` when these data are uploaded into `R`. Luckily, again the `filter` function has a solution to this! We can filter the data to remove rows with `NULL` or `NA` entries.

```{r}
#filter the data to remove rows with null values in the height column
filter(data, !is.na(width))
```

Observe that row 12 of `data` has now been removed because it contained `NA` in the `width` column. To understand this command, note that `is.na(x)` returns `TRUE` if `x = NA`. The `!` means 'not' and reverses the `TRUE` and `FALSE` outputs. We illustrate `!` below:

```{r}
# 1 equal to 2 (FALSE)
1 == 2

# 1 is not equal to 2 (TRUE)
1 != 2
```


Recall, that `filter()` retains the rows that evaluate as `TRUE`: we wish to remove the rows with `NA`, so we need to write a command that evaluates these to `FALSE`. Therefore, we use `!is.na()`.


<!-- R not only allows us to add columns to an existing data frame, but it can also allow us to create new data frames. Here, we will be creating a new data frame called `shrub_volumes` that contains the columns from `data`, and a new column called `volume`. -->

<!-- ```{r} -->
<!-- # Create a new data frame called shrub_volumes that has all the original data plus a new column containing volumes -->

<!-- shrub_volumes <- mutate(ShrubData, volumes = length * width * height) -->

<!-- head(shrub_volumes) -->
<!-- ``` -->

<!-- **HAND IN** Create a new data frame called shrub_volume and include the `tail()` print out. -->

<!-- ### Code Shuffle -->

<!-- In this section, we are interested in understanding the monthly variation in precipitation in Gainesville, FL. We'll use some data from the [NOAA National Climatic Data Center](https://www.ncdc.noaa.gov/). -->

<!-- Each row of the data is a year (from 1961-2013) and each column is a month (January - December). -->

<!-- In this section, we want you to  -->

<!-- - import the `weather_data` from Brightspace  -->

<!-- - calculate the average precipitation in each month across years  -->

<!-- - plot the monthly averages as a simple line plot -->



<!-- ```{r, include=F} -->
<!-- weather.data <- read.csv(file = "lab_data/gainesville-precip.csv", header=F) -->
<!-- monthly_mean_ppt <- colMeans(weather.data) -->
<!-- ``` -->

<!-- We can use the `colMeans` function to take the mean of each column within a data frame. **We will be demonstrating this using the `ShrubData` but you will use the weather data.** -->

<!-- ```{r} -->
<!-- col_means <- colMeans(ShrubData) -->
<!-- # To show the column means, you will need to use the print() command -->
<!-- print(col_means) -->
<!-- ``` -->

<!-- We can see that the means for each column was calculated. **HAND IN** Using the `weather_data`, calculate the mean precipitation for each month and produce a simple line plot. You will **hand in both** the R code and the plot. Your plot should resemble the line plot below. **You will need to change the axis titles.** -->

<!-- ```{r, echo=FALSE} -->
<!-- plot(monthly_mean_ppt, type = "l", xlab = "Month", ylab = "Mean Precipitation (ml)") -->
<!-- ``` -->

<!-- ### Bird Banding -->

<!-- The number of birds banded at a series of sampling sites has been counted by your field crew and entered into the following vector.  -->

<!-- ```{r} -->
<!-- number_of_birds <- c(28, 32, 1, 0, 10, 22, 30, 19, 145, 27,  -->
<!--                      36, 25, 9, 38, 21, 12, 122, 87, 36, 3, 0, 5, 55, 62, 98, 32,  -->
<!--                      900, 33, 14, 39, 56, 81, 29, 38, 1, 0, 143, 37, 98, 77, 92,  -->
<!--                      83, 34, 98, 40, 45, 51, 17, 22, 37, 48, 38, 91, 73, 54, 46, -->
<!--                      102, 273, 600, 10, 11) -->
<!-- ``` -->
<!-- Counts are entered in order and sites are numbered starting at one. Using the following vector, answer the following questions and print the results on the screen. The following functions maybe useful: `length()`, `max()`, `min()`, `sum()`, and `mean()`. -->


<!-- **Function Overview** -->

<!-- -   `max()` indicates the maximum value in a vector -->

<!-- -   `min()` indicates the minimum value in a vector -->

<!-- -   `length()` indicates the total number of rows, or length of entries in a vector -->

<!-- -   `sum()` adds or takes the sum of all values in a column -->

<!-- -   `mean()` calculates the mean for a vector -->


<!-- **HAND IN** Answer the following using the commands provided above.  -->

<!-- 1) How many sites are there? -->

<!-- 2)  What is the total number of birds counted across all of the sites? -->

<!-- 3)  What is the smallest number of birds counted? -->

<!-- 4)  What is the largest number of birds counted? -->

<!-- 5)  What is the average number of birds seen at a site? -->

<!-- 6)  How many birds were counted at the last site? Have the computer choose the last site automatically in some way, not manually entering its position. Do you know a function that will give you a position of the last value? (since positions start at 1 position of the last value in a vector is the same as its length) -->

<!-- 7)  How many birds were counted at site 42? -->


<!-- ```{r, include=F, echo=F} -->
<!-- # Answers to the questions -->

<!-- #how many sites -->
<!-- length(number_of_birds) -->

<!-- #how many birds at site 42 -->
<!-- number_of_birds[42] -->

<!-- #what is total number of birds across all sites? -->
<!-- sum(number_of_birds) -->

<!-- #what is smallest number of birds counted? -->
<!-- min(number_of_birds) -->

<!-- #what is largest number of birds counted? -->
<!-- max(number_of_birds) -->

<!-- #what is average number of birds per site? -->
<!-- mean(number_of_birds) -->

<!-- #how many birds were at the last site (without entering position) -->
<!-- number_of_birds[length(number_of_birds)] -->

<!-- ``` -->

<!-- ### Portal Data Manipulation -->

<!-- Download a copy of the `survey data` from Brightspace and load it into R using `read.csv()`. -->

<!-- ```{r, include=F} -->

<!-- survey <- read.csv("lab_data/surveys.csv") -->

<!-- ``` -->

<!-- **HAND IN** Answer the following.  -->

<!-- 1.  Using the `select()` function create a new data frame called `survey_new` that only contains the columns `year`, `month`, `day`, and `species_id` in that order. -->

<!-- 2.  Using the `mutate()`, `select()`, `filter()`, and `!is.na()` functions to create a new data frame with only `year()`, `species_id` and `weight()` in **kilograms of each individual**. The weight in the table is given in grams, so you will need to create a new column or convert weight into kilograms. (*Recall that 1 g = 0.001 kg.*) -->

<!-- 3.  Use the `filter()` function, print only the rows in the data frame for the species ID =`SH`. -->

<!-- ### Portal Data Manipulation Pipes  -->

<!-- Using the `survey data` we will be using the `%>%` pipe operations to manipulate the data. The pipe operation can be used to easy combine previous functions. -->

<!-- The pipe function allows for separate functions to be combined. For example, instead of creating two data frames where one removes `na` entries and the other adds new columns, the pipe operation combines them. Below is an example, I will create a new data frame with only `month()`, `plot_id()` and a new column `wight_mil`. -->

<!-- ```{r} -->
<!-- new_pipe_survey_df <-  -->
<!--           survey %>%  -->
<!--            filter(!is.na(weight)) %>% -->
<!--             mutate(weight_mil=weight*100) %>% -->
<!--             select(month, plot_id, weight_mil) -->

<!-- ``` -->

<!-- You can see that the same functions are used above in section **2.1.4 Portable Data Manipulation**, but rather than listing each command individually, the functions are connected via the `%>%` pipe operation. -->

<!-- **HAND IN:** Using the `%>%` operation, answer the following questions. -->

<!-- 1.  Using the `mutate()`, `select()`, `filter()`, and/or `!is.na()` functions to create a new data frame with only `year()`, `species_id` and `weight()` in **kilograms of each individual**. -->

<!-- 2.  Use the `filter()` and `select()` to get the `year`, `month`, `day`, `weight` in kg, and `species_id` columns for all of the rows in the data frame where `species_id` is `SH`. Use the `head()` command to print the top of the data frame. -->

<!-- ```{r, echo=F} -->

<!-- head(survey %>% -->
<!-- filter(species_id == "SH") %>% -->
<!-- filter(!is.na(weight)) %>% -->
<!--             mutate(weight_kg=weight/100) %>% -->
<!--             select(year, month, day, weight_kg, species_id) -->
<!-- ) -->
<!-- ``` -->

<!-- Above is the `head()` print out of the `%>%` piped operation. Does it look similar to yours? -->
