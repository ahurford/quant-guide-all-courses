[["handling-data.html", "8 Handling data 8.1 Base R 8.2 dplyr 8.3 Reshaping Data", " 8 Handling data Base R refers to functions that come with an installation of R, not those that are in packages that are must be installed. We will learn how to handle data both using the base R functions, and using the package dplyr. 8.1 Base R 8.1.1 Useful functions max() outputs the maximum value in a vector (recall, a vector is a list of numbers, e.g., c(0,2,5)), matrix, or data frame; min() outputs the minimum value in a vector, matrix, or data frame; length() outputs the total number of elements, in a vector, matrix, or data frame; sum() adds or takes the sum of all values in a vector, matrix, or data frame; mean() calculates the mean of all values in a vector or matrix; colMeans() calculates the mean of a column in a matrix or data frame. head() prints the first 6 rows of the argument to your console. This can be helpful if you want to check your data without having to sort through a long output. tail() similar to head() but prints the last 6 rows of the argument. TRY IT! In the Console do some tests on these functions by creating a test matrix and a test data frame: test = data.frame(col1 = c(0,2), col2 = c(5,6)) test2 = matrix(c(2,3),c(5,1),nrow=2) mean(test) ## Warning in mean.default(test): argument is not numeric or logical: returning NA ## [1] NA colMeans(test) ## col1 col2 ## 1.0 5.5 mean(test2) ## [1] 2.5 colMeans(test2) ## [1] 2.5 2.5 2.5 2.5 2.5 Which command generates an error? Why? How is mean() different to colMeans()? Is the length(), when applied to a data frame or matrix, equal to the number of rows? 8.1.2 Extracting rows and columns After we have loaded/imported our data we want to be able to work with it. Typical operations are to extract specific columns, rows, or values, and to add new columns and rows. Recall that columns run top to bottom, while rows run left to right. In addition, columns will sometimes have names: names(data) ## [1] &quot;site&quot; &quot;experiment&quot; &quot;length&quot; &quot;width&quot; &quot;height&quot; To extract a column, we use the symbol $ followed by the name of the column (in this case site): data$site ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 If the columns do not have names you can specify the column you require by using data[,n], where n is the number of column you require (beginning from the left). When no number precedes the ,n this means all rows: data[,1] ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 To extract row n, and all the columns, we use data[n,]. Row 1 (all columns) is extracted as: data[1,] ## site experiment length width height ## 1 1 1 2.2 1.3 9.6 If we want one specific value, data[n,m] returns the value in row n and column m: data[1,2] ## [1] 1 Furthermore, data[,n:m] returns all the rows for columns n to m: data[2:4,] ## site experiment length width height ## 2 1 2 2.1 2.2 7.6 ## 3 1 3 2.7 1.5 2.2 ## 4 2 1 3.0 4.5 1.5 while data[n:m,] returns all the columns for rows n to m: data[,2:3] ## experiment length ## 1 1 2.2 ## 2 2 2.1 ## 3 3 2.7 ## 4 1 3.0 ## 5 2 3.1 ## 6 3 2.5 ## 7 1 1.9 ## 8 2 1.1 ## 9 3 3.5 ## 10 1 2.9 ## 11 2 4.5 ## 12 3 1.2 Note that in the two examples above n must be bigger than m. This method is called slicing. This are simple commands to work with data, but as data scientists frequently want to work with data in this way, the dplyr package was created to handle data more efficiently. 8.2 dplyr We recommend using dplyr to handle data as the commands are concise, making the code easier to read and write. Install and load the dplyr R package. The dplyr package contains several different function that are very useful when manipulating and cleaning large datasets. We will be highlighting the use of the select(), mutate(), length(), arrange(), and filter(). 8.2.1 Selecting a column The command select(data, length) selects the length column of the dataframe data: select(data, length) ## length ## 1 2.2 ## 2 2.1 ## 3 2.7 ## 4 3.0 ## 5 3.1 ## 6 2.5 ## 7 1.9 ## 8 1.1 ## 9 3.5 ## 10 2.9 ## 11 4.5 ## 12 1.2 This achieves the same result as the data$length command we learned in the previous section. 8.2.2 Adding a new column There are several different methods to add new columns to a data set in R, but when using the dplyr package, the function mutate() is appropriate. Below we create a new column called site_double that is equal to the site column times 2. data2 = mutate(data, site_double = site * 2) We can see that data2 has a new column called site_double. 8.2.3 Sorting the data The arrange() function orders the rows of a data frame by the values in a specific column. Below we arrange data by increasing order of the width column.: arrange(data, width) ## site experiment length width height ## 1 3 2 1.1 0.5 2.3 ## 2 1 1 2.2 1.3 9.6 ## 3 1 3 2.7 1.5 2.2 ## 4 3 1 1.9 1.8 4.5 ## 5 3 3 3.5 2.0 7.5 ## 6 1 2 2.1 2.2 7.6 ## 7 4 1 2.9 2.7 3.2 ## 8 2 3 2.5 2.8 3.0 ## 9 2 2 3.1 3.1 4.0 ## 10 2 1 3.0 4.5 1.5 ## 11 4 2 4.5 4.8 6.5 ## 12 4 3 1.2 NA 2.7 8.2.4 Filtering data The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. For a row to be retained, TRUE must be produced for all conditions. To extract all rows of data with length greater than 7 cm: filter(data, height &gt; 7) ## site experiment length width height ## 1 1 1 2.2 1.3 9.6 ## 2 1 2 2.1 2.2 7.6 ## 3 3 3 3.5 2.0 7.5 We can also filter with two (or more) conditions. We use &amp; (meaning and) if we require both conditions to be satisfied, or | (meaning or) if we require at least one condition is satisfied. Below, we filter the data so that data3 contains only plants that have length greater than 8 cm and width greater than 5 cm. data3=filter(data, height &gt;8 &amp; width &gt; 5) However, no plants met both conditions so data3 is empty. We can filter to retain plants from Site 1 or Site 3: filter(data, site == 1 |site == 3) ## site experiment length width height ## 1 1 1 2.2 1.3 9.6 ## 2 1 2 2.1 2.2 7.6 ## 3 1 3 2.7 1.5 2.2 ## 4 3 1 1.9 1.8 4.5 ## 5 3 2 1.1 0.5 2.3 ## 6 3 3 3.5 2.0 7.5 In R, == evaluates whether something is TRUE or FALSE, while = assigns the value on the right hand side to the variable on the left hand side. TRY IT In the Console try the following: # Assigns x the value 0 x = 0 # Evaluates TRUE if x = 0 (TRUE since we assigned x=0 on the above line of code) x == 0 ## [1] TRUE # Evalues TRUE if x = 1 (FALSE since we assigned x=0 on the first line of code) x == 1 ## [1] FALSE Therefore, when we write site == 1, TRUE is returned when the value of site is 1, and these rows are retained in the output. If we wrote site = 1, then R would try to assign the variable site with the value 1, which would return an error message since the second argument of the filter() function requires a logical statement that evaluates as TRUE or FALSE and site = 1 assigns a value; it is not a logical statement. 8.2.5 Removing NA entries in data Often experimental data is not as neat or pretty as example data. There is often missing data, or empty or NA entries which may cause issues in graphing or data analysis. R does not allow empty values, so empty values in .csv or .xlsx files are often converted to NA when these data are uploaded into R. Luckily, again the filter function has a solution to this! We can filter the data to remove rows with NULL or NA entries. #filter the data to remove rows with null values in the height column filter(data, !is.na(width)) ## site experiment length width height ## 1 1 1 2.2 1.3 9.6 ## 2 1 2 2.1 2.2 7.6 ## 3 1 3 2.7 1.5 2.2 ## 4 2 1 3.0 4.5 1.5 ## 5 2 2 3.1 3.1 4.0 ## 6 2 3 2.5 2.8 3.0 ## 7 3 1 1.9 1.8 4.5 ## 8 3 2 1.1 0.5 2.3 ## 9 3 3 3.5 2.0 7.5 ## 10 4 1 2.9 2.7 3.2 ## 11 4 2 4.5 4.8 6.5 Observe that row 12 of data has now been removed because it contained NA in the width column. To understand this command, note that is.na(x) returns TRUE if x = NA. The ! means ‘not’ and reverses the TRUE and FALSE outputs. We illustrate ! below: # 1 equal to 2 (FALSE) 1 == 2 ## [1] FALSE # 1 is not equal to 2 (TRUE) 1 != 2 ## [1] TRUE Recall, that filter() retains the rows that evaluate as TRUE: we wish to remove the rows with NA, so we need to write a command that evaluates these to FALSE. Therefore, we use !is.na(). 8.2.6 Grouping The functiongroup_by() can be used with summarize() and tally(). Recall that our data consists of different sites: head(data) ## site experiment length width height ## 1 1 1 2.2 1.3 9.6 ## 2 1 2 2.1 2.2 7.6 ## 3 1 3 2.7 1.5 2.2 ## 4 2 1 3.0 4.5 1.5 ## 5 2 2 3.1 3.1 4.0 ## 6 2 3 2.5 2.8 3.0 The code below calculates the mean length for each site (because we group data by site): by_site &lt;- group_by(data,site) data2 &lt;- summarize(by_site,length=mean(length)) print(data2) ## # A tibble: 4 × 2 ## site length ## &lt;int&gt; &lt;dbl&gt; ## 1 1 2.33 ## 2 2 2.87 ## 3 3 2.17 ## 4 4 2.87 Applying the function group_by() doesn’t make the data noticeably different aside from noting the grouping: by_site &lt;- group_by(data,site) head(print(by_site)) ## # A tibble: 12 × 5 ## # Groups: site [4] ## site experiment length width height ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2.2 1.3 9.6 ## 2 1 2 2.1 2.2 7.6 ## 3 1 3 2.7 1.5 2.2 ## 4 2 1 3 4.5 1.5 ## 5 2 2 3.1 3.1 4 ## 6 2 3 2.5 2.8 3 ## 7 3 1 1.9 1.8 4.5 ## 8 3 2 1.1 0.5 2.3 ## 9 3 3 3.5 2 7.5 ## 10 4 1 2.9 2.7 3.2 ## 11 4 2 4.5 4.8 6.5 ## 12 4 3 1.2 NA 2.7 ## # A tibble: 6 × 5 ## # Groups: site [2] ## site experiment length width height ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2.2 1.3 9.6 ## 2 1 2 2.1 2.2 7.6 ## 3 1 3 2.7 1.5 2.2 ## 4 2 1 3 4.5 1.5 ## 5 2 2 3.1 3.1 4 ## 6 2 3 2.5 2.8 3 The first argument, x, of summarize(x,y) is the grouped data, and the second argument, y, has the structure name of the new column = function to be applied to(column of grouped data). Recalling that the function min() calculates the minimum of its argument, we might also calculate the minimum width for each of the sites: summarize(by_site, min.width = min(width)) ## # A tibble: 4 × 2 ## site min.width ## &lt;int&gt; &lt;dbl&gt; ## 1 1 1.3 ## 2 2 2.8 ## 3 3 0.5 ## 4 4 NA The function tally() counts the number of records in each group. tally(by_site) ## # A tibble: 4 × 2 ## site n ## &lt;int&gt; &lt;int&gt; ## 1 1 3 ## 2 2 3 ## 3 3 3 ## 4 4 3 Equivalently, we could apply the function length() using summarize(): summarize(by_site,n=length(site)) ## # A tibble: 4 × 2 ## site n ## &lt;int&gt; &lt;int&gt; ## 1 1 3 ## 2 2 3 ## 3 3 3 ## 4 4 3 8.2.7 Joining A good description of joining data sets using inner_join() is provided here. 8.2.8 Pipes The pipe function, %&gt;%, allows for compact coding when the output on the lefthand size of %&gt;% is the input for the calculations performed on the righthand size of %&gt;%. Consider: data2 &lt;- data %&gt;% filter(!is.na(width)) %&gt;% mutate(height_cm=height*100) %&gt;% select(site, experiment, height_cm) head(data2) ## site experiment height_cm ## 1 1 1 960 ## 2 1 2 760 ## 3 1 3 220 ## 4 2 1 150 ## 5 2 2 400 ## 6 2 3 300 We end up with a new dataframe, data2, that is data with three operations sequentially performed. The advantage of using %&gt;% is the compactness and clarity of the code to achieve this result. Let’s understand these commands further. data2 is the name of the output when we are finished all our operations; data is the data that we start with; filter(!is.na(width)) removes all rows with NA in the width column of data. In the previous sections, when we demonstarted filter(x,y), the first argument, x, was a dataframe, and the second argument was a logical statement, i.e., !is.na(width). Above, when %&gt;% is used only the logical statement is provided and the data that the function applies to is supplied on the left hand side of %&gt;%. mutate(height_cm=height*100) converts height in meters to centimeters, and this operation is applied to all the data that passed through the pipe from the previous operation where NAs in the width column were removed. select(site, experiment, height_cm) is used to output only columns of interest, and again, the data argument to the select() function is supplied by the lefthand size of the pipe. Note that the pipes will not work if the output of one operation is of the wrong type to be the input to the next operation. To understand the value of pipes, consider the equivalent code written without using pipes: data2 &lt;- filter(data,!is.na(width)) data3 &lt;- mutate(data2,height_cm=height*100) data4 &lt;- select(data3, site, experiment, height_cm) head(data4) ## site experiment height_cm ## 1 1 1 960 ## 2 1 2 760 ## 3 1 3 220 ## 4 2 1 150 ## 5 2 2 400 ## 6 2 3 300 Without using pipes, we create variables data2 and data3 that only serve as intermediaries, that we may never use again in our subsequent lines of code. Creating many variables can bog down both the computer memory and your own memory, when you are trying to remember the variable name you gave to a particular output when writing subsequent commands. 8.3 Reshaping Data Data frequently come in formats that are unsuitable for analysis. You would be required to do modifications on the data in some way. The process of cleaning or modifying the data to make it ready for analysis is known as tidying, or munging. The goal is generally to get the data into a tidy format. You often get data where items that should be in the rows are in the columns or vice versa yet it’s not in a transpose form. Some plotting functions in R have a special way the data should be formatted before it can produce the required plot. In these circumstances, you would have to reshape the data into a format that is easier to work with. The common formats that data is usually formatted into are a wide or long format. Depending on your goal, you may want the data frame to be in one of these specific formats. We hereby going to learn how to reshape data into one of these formats. 8.3.1 Reshaping data from wide to long format 8.3.1.1 Base R "]]
